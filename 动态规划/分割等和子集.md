# 分割等和子集 #
## 题目： ##
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。


## 示例 1： ##



> 输入： [1, 5, 11, 5]


> 输出：true


> 解释：数组可以分割成 [1, 5, 5] 和 [11].

## 示例 2： ##



> 输入：[1, 2, 3, 5]

> 输出：false


> 解释：数组不能分割成两个元素和相等的子集.



## 解题思路： ##


这道题可以换一种表述：给定一个只包含正整数的非空数组 nums，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。求解方法为动态规划。

判断边界条件：

- 根据数组的长度 nn 判断数组是否可以被划分。如果 n<2，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。

- 计算整个数组的元素和sum以及最大元素maxNum。如果sum 是奇数，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。如果sum 是偶数，则令 target=sum/2，需要判断是否可以从数组中选出一些数字，使得这些数字的和等于target。如果maxNum>target，则除了maxNum 以外的所有元素之和一定小于target，因此不可能将数组分割成元素和相等的两个子集，直接返回false。

创建二维数组dp，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。
继续判断规划中的边界条件：

如果nums[i]j≥nums[i]，则对于当前的数字nums[i]，可以选取也可以不选取，两种情况只要有一个为true，就有dp[i][j]=true。



1. 如果不选取nums[i]，则dp[i][j]=dp[i−1][j]


1. 如果选取nums[i]，则dp[i][j]=dp[i−1][j−nums[i]]。

如果j<nums[i]，则在选取的数字的和等于 j 的情况下无法选取当前的数字nums[i]，因此有dp[i][j]=dp[i−1][j]。

## 解决代码： ##
    class Solution:
    	def canPartition(self, nums: List[int]) -> bool:
        	n = len(nums)
        	if n < 2: # 边界条件，一个数无法分
            	return False
        
        	total = sum(nums)
        	maxNum = max(nums)
        	if total & 1: # 边界条件，和为奇数无法分
            	return False
        
        	target = total//2
        	if maxNum > target: # 边界条件，最大数字比一半和大，那么剩下数字一定比一半和小，没法分
            	return False
			
			# dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于j
        	dp = [[False] * (target+1) for _ in range(n)] 
        	for i in range(n):
            	dp[i][0] = True
        
        	dp[0][nums[0]] = True
        	for i in range(1, n):
            	num = nums[i]
            	for j in range(1, target+1): # 这里遍历时边界条件如上述
                	if j >= num:
                    	dp[i][j] = dp[i-1][j] or dp[i-1][j-num]
                	else:
                    	dp[i][j] = dp[i-1][j]

        	return dp[n-1][target]
