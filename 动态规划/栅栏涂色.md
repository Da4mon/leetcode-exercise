# 栅栏涂色 #
## 题目： ##
有 k 种颜色的涂料和一个包含 n 个栅栏柱的栅栏，请你按下述规则为栅栏设计涂色方案：



- 每个栅栏柱可以用其中 一种 颜色进行上色。


- 相邻的栅栏柱 最多连续两个 颜色相同。

给你两个整数 k 和 n ，返回所有有效的涂色 方案数 。


## 示例 1： ##

![](https://assets.leetcode.com/uploads/2021/02/28/paintfenceex1.png)

> 输入：n = 3, k = 2


> 输出：6


> 解释：所有的可能涂色方案如上图所示。注意，全涂红或者全涂绿的方案属于无效方案，因为相邻的栅栏柱 最多连续两个 颜色相同。

## 示例 2： ##



> 输入：n = 1, k = 1


> 输出：1

## 示例 3： ##


> 输入：n = 7, k = 2

> 输出：42


## 解题思路： ##
动态规划，用dp两维数组，分别表示：



dp[i][0]表示在涂第i个栅栏时，和前一个栅栏颜色不同的方案数，那么dp[i][0]可以是

1. dp[i-1][0]*可用颜色种类数，此时颜色种类数应该为(k-1),因为规定了i和i-1不能同色，所以排除一种颜色。
2. dp[i-1][1]*可用颜色种类数，同理由于前一个栅栏已经重复颜色，所以这种颜色也被排除，只能挑选剩下颜色涂。

dp[i][1]表示表示在涂第i个栅栏时，和前一个栅栏颜色相同的方案数，那么dp[i][1]只能是dp[i-1][0]


## 解决代码： ##
    class Solution:
    	def numWays(self, n: int, k: int) -> int:
        	if not n and not k:
            	return 0
        	dp = [[0,0] for _ in range(n)]
        	dp[0][0],dp[0][1] = k, 0
        	for i in range(1, n):
            	dp[i][0] = (k-1) * (dp[i-1][0] + dp[i-1][1])
            	dp[i][1] = dp[i-1][0]
        	return (dp[-1][1] + dp[-1][0])