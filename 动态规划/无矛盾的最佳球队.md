# 无矛盾的最佳球队 #
## 题目： ##
假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。

然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。

给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。


## 示例 1： ##

> 输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]

> 输出： 34


> 解释：
你可以选中所有球员。

## 示例2：  ##

> 输入：scores = [4,5,6,5], ages = [2,1,2,1]

> 输出：16

> 解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。


## 示例3： ##

> 输入：scores = [1,2,3,5], ages = [8,9,10,1]

> 输出：6

> 解释：最佳的选择是前 3 名球员。


## 解题思路： ##
动态规划，首先需要将队员的年龄和分数进行排序，排序方式为：

1. 按照年龄从小到大排序
1. 相同年龄情况下，按照分数从小到大排 

这样排序的目的是可以在后序的操作中，取得这样一种效果，如果后面一个人的分数比前面一个人高，那么他一定可以加入到队伍种，原因是此前的这种排序方式考虑了同年龄状况和“老手和新手”的情况。

接下来我们可以通过动态规划比较，dp[i]代表第i个队员为结尾的队伍的最大得分，则dp[i]可以是之前的某个队员为结尾的队伍的最大得分dp[k]再加上第i个队员的得分（如果这个队员符合要求，即年龄与分数双要求），而这样的得分计算方式需要考虑在第i个队员之前的每一种dp[k]，从中需得出最大的进行更新。例如，要求dp[100]即以第100个队员为结尾的队伍最大得分，则可以求得dp[50]，随后将第100个队员的分数与第50个队员的年龄，由于分数为从小到大排序因此不用考虑，而年龄只有高于第50个队员才可加入队伍（老手和新手），那么此时队伍欢迎新队员加入，则dp[100]为dp[50]+第100名队员的分数。接下来同理可得dp[100]可以是dp[51]和第100个队员的比较，如果符合要求也可以是dp[51]+第100名队员的分数.如此比较下来，最大的那个就是dp[100]的值。
## 解决代码 ##
    class Solution:
    	def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        	n = len(scores) 
        	player = list(zip(ages, scores)) # 将年龄与分数放入一个列表中
        	player.sort(key = lambda x: (x[0], x[1])) # 将此player列表进行排序，排序第一准则为年龄，第二准则为分数
        	dp = [player[i][1] for i in range(n)] # dp即代表第i个队员为结尾的队伍的最大得分，初始化为排序后每个队员的得分
        	for i in range(n): # 循环生成dp
            	for j in range(i): # 循环比较第i个队员之前的dp[k]，如果符合要求，则可以加上。
                	if player[i][1] >= player[j][1]:
                    dp[i] = max(dp[i], dp[j]+player[i][1])
        	return max(dp)
